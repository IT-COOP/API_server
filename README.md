![image](https://user-images.githubusercontent.com/82748285/162229805-ae28866d-0da7-4e36-9f53-b3d81d83443d.png)

# 🤔[ItCoop][itcooplink]

[itcooplink]: https://it-coop.co.kr 'go itCoop'

#### 사이드 프로젝트와 창업을 위한 사람들의 커뮤니티

---

## ❓WHY IT-COOP ?

### 사이드 프로젝트에 대한 관심과 중요성이 높아지는 요즘!

- 무에서 유를 창조하는 경험! 내가 직접 기획부터 참여, 배포까지
- 창업을 함께 할 동료 & 다른 직군의 인맥 생성
- 커리어 탐색 및 커리어적 성장
- 채용, 이직을 위한 발돋움
- 반복되던 삶이 아닌 새로운 자극, 기대감

<hr/>

## 프로젝트 소개

### Architecture

![image](https://user-images.githubusercontent.com/48893036/162189441-14f99bf8-740a-497d-986d-136c32d5d371.png)

<hr/>

### 프로젝트 기간

- 3월 3일 ~ 4월 9일 (38일)

<hr/>

### 기능

#### 간단하고 안전한 회원가입

- 구글, 깃허브, 카카오를 통한 소셜 로그인으로 간단하고 안전하게 회원가입 할 수 있어요!

#### 😃 나를 나타내는 프로필

- 나를 어필하는 프로필을 작성 할 수 있어요!

#### 😃 원하는 게시물을 필터 기능으로 간편하게

- 지역, 직군, keep 많이 한 게시물, 최신 순 별로 프로젝트 게시물을 확인할 수 있어요!

#### 😃 원하는 포지션에 참가 신청하고 함께하는 사람들의 정보 확인

- 참여하고 싶은 프로젝트에 원하는 포지션으로 참가 신청이 가능해요
- 같이 프로젝트에 참여하는 사람들의 프로필을 확인할 수 있어요

#### 😳 할지 말지 고민될 때는 바로 KEEP IT!

- 고민되는 게시물 혹은 참고하고 싶은 게시물을 keep 할 수 있어요
  👉 나중에 keep한 게시물은 한번에 모아볼 수 있어요!!

#### 😜 원활한 프로젝트를 위해 팀원들과 소통하기

- 진행 중인 프로젝트의 팀 별 메신저 기능을 제공해드려요

#### 🤠 ”다음에 또 협업 하고 싶어요!” 함께한 팀원 평가하기

- 프로젝트 종료 후 팀원들에 대한 평가를 할 수 있어요!
<hr/>

## 🛠 Tools

#### 디자인

<p>
  <img src="https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=Figma&logoColor=white"/>
  <img src="https://img.shields.io/badge/Adobe XD-FF61F6?style=for-the-badge&logo=Adobe XD&logoColor=white"/>
  <img src="https://img.shields.io/badge/Adobe Illustrator-FF9A00?style=for-the-badge&logo=Adobe Illustrator&logoColor=white"/>
  <img src="https://img.shields.io/badge/Adobe Photoshop-31A8FF?style=for-the-badge&logo=Adobe Photoshop&logoColor=white"/>
  <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white">
<br>
</p>

####백엔드

<p>
<img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">
<img src="https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=TypeScript&logoColor=white"/>
<img src="https://img.shields.io/badge/ESLint-4B3263?style=for-the-badge&logo=eslint&logoColor=white">
<img src="https://img.shields.io/badge/node.js-339933?style=for-the-badge&logo=Node.js&logoColor=white">
<img src="https://img.shields.io/badge/NestJS-E0234E?style=for-the-badge&logo=NestJS&logoColor=white">

<br>
  <img src="https://img.shields.io/badge/mysql-%2300f.svg?style=for-the-badge&logo=mysql& logoColor=white">
  <img src="https://img.shields.io/badge/NPM-%23000000.svg?style=for-the-badge&logo=npm&  logoColor=white">
  <img src="https://img.shields.io/badge/AWS Ec2-232F3E?style=for-the-badge&  logo=amazonaws&logoColor=white">
   <img src="https://img.shields.io/badge/socket.io-ffffff?style=for-the-badge&logo=socket.io&logoColor=black">
  <img src="https://img.shields.io/badge/JWT-black?style=for-the-badge&logo=JSON%20web%20tokens">

<br>
</p>

####frontEnd

<p>
  <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">
  <img src="https://img.shields.io/badge/Tailwind-06B6D4?style=for-the-badge&logo=Tailwind CSS&logoColor=white">
  <img src="https://img.shields.io/badge/html-E34F26?style=for-the-badge&logo=html5&logoColor=white">
  <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white">
  <img src="https://img.shields.io/badge/ESLint-4B3263?style=for-the-badge&logo=eslint&logoColor=white">
  <img src="https://img.shields.io/badge/yarn-%232C8EBB.svg?style=for-the-badge&logo=yarn&logoColor=white">
  <br>
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=React&logoColor=black">
  <img src="https://img.shields.io/badge/React_Router-CA4245?style=for-the-badge&logo=react-router&logoColor=white">
  <img src="https://img.shields.io/badge/-React%20Query-FF4154?style=for-the-badge&logo=react%20query&logoColor=white">
  <img src="https://img.shields.io/badge/socket.io-ffffff?style=for-the-badge&logo=socket.io&logoColor=black">
<br>
  <img src="https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white">
  <img src="https://img.shields.io/badge/CloudFront-D05C4B?style=for-the-badge&logo=Amazon AWS&logoColor=white">
  <img src="https://img.shields.io/badge/Amazon S3-569A31?style=for-the-badge&logo=Amazon S3&logoColor=white">
</p>

####Dev tools

<p> 
  <img src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white">
  <img src="https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white">
  <img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white">
<br>

<hr>

| 이름       | 포지션       | 깃허브 or 개인 블로그          |
| ---------- | ------------ | ------------------------------ |
| **황태영** | `프론트엔드` | https://github.com/hty0525     |
| **오세명** | `프론트엔드` | https://github.com/nemyung     |
| **이승민** | `백엔드`     | https://github.com/aaa22220304 |
| **이수현** | `백엔드`     | https://github.com/lshyun955   |
| **천강효** | `백엔드`     | https://github.com/beewp       |
| **김하연** | `디자이너`   |                                |
| **선유경** | `디자이너`   | 🚢 sbi66@naver.com             |

## 🔥이슈 및 트러블슈팅

<details>
<summary><b>➡️ DB 확장성 문제</b></summary>

> **문제** : DB 테이블에서 컬럼 자체가 값을 의미하여 유연성이 제한되는 문제
>
> **설명** : 게시글을 DB에 저장할 때, 작성자가 요구하는 각각의 직군 및 기술 스택과 그에 따라 필요한 인원수를 저장해야 헀다. 직군 및 기술 스택을 각각의 컬럼으로 하여 각 몇명이 요구되는 지를 저장하고 있었다. 그 결과, 백엔드에서 컬럼으로 지정한 직군 및 기술 스택에 대한 정보만을 저장하고 있었다.
>
> **해결** : 해당하는 컬럼을 모두 제거한 후, 기존 One to One 관계에서 One To Many 관계로 테이블 관계 설정을 바꾸어 기술 스택 및 직군에 대한 정보를 row에 저장하였다.
>
> **효과** : 기존의 제약에서 벗어나서 더 다양한 종류의 기술 스택의 정보를 저장할 수 있었고, 실제로 10여 가지의 정보를 저장하였던 초기 대비 프로젝트가 진행됨에 따라 20여 가지의 정보를 저장해야 했고 이를 성공적으로 저장할 수 있었다.
</details>

<details>
<summary><b>➡️ 페이지 네이션 구현 문제</b></summary>

> **문제1** : 여러 가지 필터와 정렬 순서에 따른 페이지네이션을 구현으로 너무 많은 분기처리가 필요했던 문제
>
> **설명** : 사용자 편의성을 개선하기 위해서 전체 게시글 목록 조회 API에서 직군, 기술 스택, 모집 완료 여부, 그리고 지역 등의 여러가지 필터 기능이 필요했고, 거기에 더해 최신순 및 keep it 갯수 순으로 정렬이 필요했다. 각각에 대해서 서로 다르게 분기 처리를 할 경우, API를 매우 다양하게 작성하거나, 분기 처리에 따라 코드에 중복되는 부분이 지속적으로 발생하여 코드의 가동성이 떨어지고 에러 처리 등에 있어서 작업 효율이 떨어지는 문제가 발생하였다.
>
> **해결** : TypeORM이 제공하는 QueryBuilder를 통해 쿼리를 작성하였다. 각각의 필터링 및 정렬에 대해 조건문을 통해 쿼리에 추가적으로 조건을 지정해주는 방식으로 코드를 작성하였다.
>
> **효과** : 각각의 분기처리를 따로 할 필요성이 사라져 코드가 중복되는 부분이 사라졌고, 코드의 가독성이 높아져 코드를 수정함에 있어 불편함이 사라졌다. 또한, 오류가 발생하였을 때 여러가지 조건에 대해서 실험을 진행하여 어떤 부분에서 오류가 발생하였는 지를 손쉽게 찾을 수 있었으며, 똑같은 부분을 여러번 수정할 필요 없이 손쉽게 버그를 고칠 수 있었다.

<br>

> **문제2** : 페이지네이션을 Keep it 갯수를 기준으로 할 경우 시간이 매우 오래 걸리는 문제
>
> **설명** : 사용자의 편의성을 고려하여 사용자들에게 가장 큰 관심을 받는 게시물을 먼저 볼 수 있게 하는 Keep it 갯수 순으로 전체 목록을 받을 수 있게 하였습니다. 그러나, DB 구조 상 매번 Keep it의 갯수를 계산해야 하는 문제가 있었고, 그에 따라 쿼리문을 작성할 경우 매 요청에 대해 DB에 저장된 모든 게시글의 Keep it에 대한 정보를 불러오고 계산해야 하는 문제가 있어 시간이 매우 오래 걸렸다.
>
> **해결** : 게시글에 대한 정보를 저장할 때, Keep it에 대한 갯수를 저장하는 컬럼을 추가하여 이를 기준으로 정렬을 쉽게 할 수 있도록 하였다.
>
> **효과** : 각각의 요청에 있어 매번 DB의 모든 게시글에 대해서 Keep it의 갯수를 계산해야 했던 기존 방식 대비 훨씬 빠른 속도로 요청이 처리되는 것을 확인하였고, 서버의 부하 또한 감소시킬 수 있었다.
</details>

<details>
<summary><b>➡️ 수정 및 삭제 시 롤백 문제</b></summary>

> **문제** : 하나의 요청에 대해서 DB에 여러번 업데이트가 필요한 경우, 중간에 에러가 발생했을 때 의도치 않은 정보 수정이 발생했던 문제
>
> **설명** : 게시글에 Keep it에 대한 컬럼을 추가하여 Keep it을 하거나 취소했을 경우, 해당 컬럼의 정보 또한 수정해야 했다. 또한, 게시글을 수정할 때 여러가지 정보를 한번에 수정할 경우 하나의 테이블이 아니라 One to Many 관계에 있는 서로 다른 테이블의 정보를 수정해야 하는 경우가 존재했다. 그러나, 중간에 에러가 발생하여 작업이 중지된 경우, 어떤 부분에서 에러가 발생한 것인지 알 수 없으며 그 이전에 실시된 수정 사항에 대해서는 반영되는 문제가 발생하였다.
>
> **해결** : Transaction을 통해 문제를 해결하였다. Transaction은 My SQL에서 지원하는 기능으로, TypeORM에서도 이용할 수 있었다. Transaction은 그 특성 상 해당하는 모든 쿼리문이 반영되거나, 에러가 발생할 경우 모두 반영되지 않는데 이러한 특성이 문제 해결에 주요하게 작용하였다. try catch문을 통해 에러를 감지하고 에러가 발생할 경우, transaction을 롤백시켜 모든 수정사항을 되돌릴 수 있었다.
>
> **효과** : 게시글에 대한 정보 테이블에서 Keep it의 갯수에 대해 저장된 정보가 정확하게 Keep it 갯수를 반영하게 되었다. 사용자가 작성한 게시글 수정사항이 반영되는 도중에 에러가 발생하더라도 부분적으로 반영되는 것이 아니라 다시 원래 상태로 정상적으로 돌아오게 되었다. 
</details>

<details>
<summary><b>➡️ 대댓글 구현 문제</b></summary>

> **문제** : 대댓글을 구현함에 있어 일차원 배열의 정보를 트리 구조로 변환해야 하여 시간 복잡도가 O(n²)이던 문제
>
> **설명** : DB에 댓글에 대한 정보를 저장할 때, depth를 저장하여 해당 댓글이 댓글인지 대댓글인지를 저장하고, group을 저장하여 해당 댓글 및 대댓글이 몇번째 댓글 및 대댓글인지에 대한 정보를 저장하였다. 이 경우, 프론트엔드에서 일차원 배열을 이중 for문을 활용해 트리 구조로 변환해야 했기 때문에 시간 복잡도가 O(n²)이었고, 댓글의 수가 많아질 경우 문제가 발생할 것으로 판단하였다. 또한, 댓글이 삭제된 대댓글을 표현할 수 있는 방법이 필요했다.
>
> **해결** : 문제를 해결하기 위해 DB 구조 수정과 트리 구조로 변환 로직 변경을 고려하였다. Type ORM은 또한 tree 구조를 지원하여 이렇게 DB 구조를 변환할 경우 문제를 해결할 수 있다. 그러나, 이렇게 될 경우 매핑에 상당히 오랜 시간이 소요될 것으로 판단하였다. 멘토님께 질문한 결과, Type ORM은 매핑에 있어 row의 수가 많아질 수록 기하급수적으로 시간이 소요됨을 알게 되어, 이 방법보다는 로직을 변환하는 방식으로 문제를 해결하기로 하였다. Javascript는 Set 자료구조를 지원하는데, set 자료형의 경우 각각의 요소가 있는 지 여부를 검사하는 것과 add가 O(1)의 시간을 소요한다. 또한 댓글은 시간 순서대로 저장되어 있는데, 이 점을 이용하여 기존 이중 for문에서 단일 for문으로 대댓글 구현하였다. 
>
> **효과** : 단일 for문으로 대댓글 로직을 변경하여 기존 O(n²)이던 시간 복잡도를 O(n)으로 개선할 수 있었다. ORM에서 추가적인 매핑 과정 없이 문제를 해결할 수 있어 다른 부분에서 시간이 추가적으로 소요되는 부분을 걱정할 필요가 없었다. 
</details>

<details>
<summary><b>➡️ 부하 테스트</b></summary>

> **문제** : 부하 테스트 라이브러리인 artillery를 통해 서버에 부하를 가했을 때, 요청 처리 시간이 너무 오래 걸리던 문제
>
> **설명** : 부하 테스트 라이브러리인 artillery를 통해 요청이 가장 잦을 것으로 생각되는 전체 게시글 목록 조회 API에 대한 부하 테스트를 진행하였다. 기존 200ms 이하이던 요청 처리 시간이 평균 1500ms으로 증가하였고, 하위 99%의 경우 3000ms 이상이 소요되었다. 또한, 부하를 더 강하게 했을 때는 요청이 정상적으로 응답을 받을 수 없는 문제가 발생하였다.
>
> **해결** : TypeORM의 로깅 기능으로 해당 API에서 이용되는 쿼리문을 읽을 수 있었다. 해당 쿼리문에서 이용되는 조건문 및 정렬 기준을 토대로 테이블의 index를 점검 및 수정하였다.
>
> **효과** : 부하 테스트를 재실시하였을 때, 평균 소요 시간을 20% 정도 감축할 수 있었으며, 하위 99%의 경우에는 최대 50%까지 시간 소요가 감소하는 것을 확인하였다.
</details>

## more info

<details>
<summary> DB ERD </summary>
<div markdown="1">

![image](https://user-images.githubusercontent.com/48893036/162195875-c367e352-da7b-4195-bd3b-33298abf7b43.png)

</div>
</details>

###### 교훈 1 Service의 constructor 안에는 injectable한 친구들만 import해서 넣어야 한다.

###### 교훈 2 Nestjs 서버를 배포하기 위해서는 dist 폴더를 따로 업로드 해주어야 한다. (프리티어 기준)

###### 교훈 3 SQL문을 모르는 상태에서 SQL문의 형태를 모사하는 typeORM의 queryBuilder를 사용하며 익숙해질 수 있었다.

###### 교훈 4 굳이 필요 없는 댓글 갯수 같은 걸 column으로 넣으면, 읽는 속도는 빨라지지만 오히려 쓰는 경우가 너무 많이 늘어난다. 가능한 한 이런 column은 최소화하되, 꼭 필요한 경우만 추가하자

###### 교훈 5 소셜 로그인 과정에서 쿼리스트링을 활용하여 필요한 것 이외의 정보를 담을 경우, 사용자가 악용하거나 버그가 생길 여지가 생긴다.

###### 교훈 6 NestJS는 꽤나 무거워서 ec2 프리티어에서는 잘 안 돌아간다.

###### 교훈 7 REST API와 SOCKET을 동시에 쓸 수 있다.

###### 교훈 8 EC2에서 npm을 이용한 패키지 설치는 조심해서 진행해야 한다.

###### 교훈 9 페이지네이션은 커서 기반 페이지네이션과 오프셋 기반 페이지네이션이 존재한다. 오프셋 기반의 경우, 실제로 DB에서 오프셋만큼의 row를 추가로 읽기 때문에 DB에 부하가 심하게 걸리고, 중간에 변동사항이 생기면 쉽게 overlap이 발생하는 단점이 존재한다.

###### 교훈 10 로그인이 필요하지 않은 경우, 토큰과 관련하여 에러를 내기보다는, 그냥 보여주는 것이 옳다.

###### 교훈 11 OAUTH를 구현하는 과정에서, 인가 코드를 요청하는 서버와 그 외 관련 API를 호출하는 서버가 동일해야 한다. 그렇지 않으면 구글의 경우 에러가 발생한다. - invalid grant

###### 교훈 12 https를 설정하기 위해서 letsencrypt를 이용할 수 있다. 이 때, standalone 등 여러 방법으로 도메인을 소유하고 있는 지 인증이 가능한데, 이 때 명령어는 sudo certbot certonly --standalone이다. 이메일과 도메인 주소를 적고, 하면 된다.

###### 교훈 13 모든 데이터는 나름의 순서가 있고, 따라서 그 순서를 생각하며 데이터를 구해야 한다.
